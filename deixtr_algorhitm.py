G = {"Адмиралтейская":
          {"Садовая": 2},
     "Садовая":
          {"Адмиралтейская": 2,
           "Звенигородская": 3,
           "Сенная площадь": 4,
           "Спасская": 3},
     "Звенигородская":
         {"Садовая": 3,
          "Пушкинская": 3},
     "Спасская":
         {"Садовая": 3,
          "Достоевская": 4,
          "Сенная площадь": 4},
     "Достоевская":
         {"Владимирская": 3,
          "Спасская": 4},
     "Владимирская":
         {"Достоевская": 3,
          "Пушкинская": 2},
     "Пушкинская":
         {"Владимирская": 2,
          "Звенигородская": 3},
     "Сенная площадь":
         {"Садовая": 4,
          "Спасская": 4}}

D = {k: 100 for k in G.keys()}
start_k = 'Адмиралтейская'
D[start_k] = 0
U = {k: False for k in G.keys()}
P = {k : None for k in G.keys()}

for i in range(len(D)):
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys():
        if D[v] > D[min_k] + G[min_k][v]:
            D[v] = min(D[v], D[min_k] + G[min_k][v])
            P[v] = min_k
    U[min_k] = True

pointer = 'Владимирская' # куда должны прийти
path = [] # список с вершинами пути
while pointer is not None: # перемещаемся, пока не придём в стартовую точку
    path.append(pointer)
    pointer = P[pointer]

path.reverse() # разворачиваем путь
for v in path:
    print(v)
print(G)